## **問題**

### **強制對齊文本修正 (Forced Alignment Text Correction)**

**問題描述**

你正在處理語音資料的強制對齊（Forced Alignment）任務。我們給定兩段中文文本：

1.  **基準文本 (Ground Truth Text):** 這是原始、正確的中文文本，例如由 TTS 模型生成的語音所對應的文本。
2.  **MFA 文本 (MFA Text):** 這是由 Montreal Forced Aligner (MFA) 工具，根據上述語音轉換而成的中文文本。

MFA 在轉換過程中，可能會因為語音品質或其他因素，將部分單字或音節識別為 **`<unk>` (未知)** 標記。你的任務是利用基準文本作為參考，將 MFA 文本中的所有 `<unk>` 標記修正為正確的中文單字。

**一個可行的修正方法如下：**

1.  將基準文本與 MFA 文本都轉換為拼音序列。
2.  在拼音序列上，找到 MFA 文本中 `<unk>` 標記的前後文（pre-sequences and post-sequences），並在基準文本的拼音序列中，尋找與之匹配的子序列。
3.  利用這個匹配結果，確定 MFA 文本中 `<unk>` 標記所對應的基準文本中的中文字，並進行替換。

**輸入**

* `ground_truth_text`: 一個字串，代表基準中文文本。
* `mfa_text`: 一個字串，代表包含 `<unk>` 標記的 MFA 中文文本。

**輸出**

* 一個字串，代表修正後的 MFA 文本。

**注意事項**

* 所有文本中的字與字之間都以空格分隔。
* `<unk>` 標記在 MFA 文本中可能會重複出現多次。
* 假設提供的拼音轉換工具是完善的，能將所有中文字正確轉換為拼音。
* 考慮到 MFA 的特性，匹配子序列時可能不需要完全精準，可以考慮一些容錯機制（例如，使用模糊匹配演算法），但為了簡化問題，我們假設可以直接使用精確匹配。

**範例**

**範例一**

* `ground_truth_text` = `"我 喜歡 學習 演算法"`
* `mfa_text` = `"我 喜歡 <unk> 算法"`

**輸出** = `"我 喜歡 學習 演算法"`

**解釋：**
1.  **轉換為拼音：**
    * `ground_truth_pinyin` = `"wo xi huan xue xi yan suan fa"`
    * `mfa_pinyin` = `"wo xi huan <unk> suan fa"`
2.  **找到 `<unk>` 的上下文：**
    * `<unk>` 的前一個拼音是 `huan`，後一個拼音是 `suan`。
3.  **在基準拼音中尋找：**
    * 在 `ground_truth_pinyin` 中，尋找 `huan` 和 `suan` 之間的內容。
    * 我們找到 `huan` 和 `suan` 之間是 `xue xi yan`。
4.  **對應回中文：**
    * `xue xi yan` 對應的中文是 `"學習 演"`。
5.  **修正：**
    * 用 `"學習 演"` 替換 `<unk>`，得到 `"我 喜歡 學習 演 算法"`。
    * **備註:** 在這個例子中，MFA 在 `"演"` 和 `"算"` 之間出錯了，所以修正後應為 `"我 喜歡 學習 演 算法"`，或者可以簡化為只替換 `<unk>` 所對應的單字。為了讓問題更明確，假設 `<unk>` 總是以一個單字為單位。

---

**約束條件**

* `ground_truth_text` 與 `mfa_text` 的長度皆介於 1 到 1000 個字之間。
* 所有字串只包含中文字、英文字母、空格與 `<unk>` 標記。

**進階思考**

* 如果 MFA 文本中有多個連續的 `<unk>` 標記，應如何處理？
* 如果 `<unk>` 標記的前後文在基準文本中有多個匹配，應如何決定？
* 如果基準文本和 MFA 文本的拼音序列長度差異很大，該如何處理？這可能表示 MFA 遺漏了部分詞語，這時單純的子序列匹配可能不再適用，需要更複雜的對齊演算法，例如 **動態時間扭曲（Dynamic Time Warping, DTW）**。